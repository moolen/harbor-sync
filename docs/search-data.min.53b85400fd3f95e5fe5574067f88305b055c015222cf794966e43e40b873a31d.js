(function(){const pages=[{"idx":0,"href":"/harbor-sync/docs/configuration/","title":"Configuration","content":" Configuration Environment Variables    ENV DEFAULT DESCRIPTION     HARBOR_API_ENDPOINT - specify the harbor URL   HARBOR_USERNAME - set the username used for authenticating with harbor   HARBOR_PASSWORD - password for harbor authentication    Commandline flags Usage: -harbor-poll-interval duration poll interval to update harbor projects \u0026amp; robot accounts (default 5m) -force-sync-interval force reconciliation interval (default 10m) -v value log level for V logs -kubeconfig string Paths to a kubeconfig. Only required if out-of-cluster. -metrics-addr string The address the metric endpoint binds to. (default \u0026quot;:8080\u0026quot;)  "},{"idx":1,"href":"/harbor-sync/docs/development/","title":"Development","content":" Development This document explains you how to get started with developing harbor-sync. It shows you how to install the prerequisites and how to build, test and run the controller.\nGet the code $ git clone https://github.com/moolen/harbor-sync.git ~/dev/harbor-sync $ cd ~/dev/harbor-sync Installing the test environment Prerequisites:  Vagrant must be installed Minikube must be installed Kubebuilder must be installed  Use the provided Vagrantfile to spin up a harbor instance.\n$ vagrant up Right now you need to click your way through harbor to create the projects for testing. Once the installation is done harbor tells you the ip address for this installation (e.g. http://172.28.128.XXX.xip.io.).\nIf it is not yet running ssh into the machine and try to start the containers with docker-compose:\n$ vagrant ssh vagrant@harbor:~$ sudo docker-compose -f harbor/docker-compose.yml up -d Tell the manager to access this deployment using environment variables:\n$ export HARBOR_API_ENDPOINT=http://172.28.128.XXX.xip.io. $ export HARBOR_USERNAME=\u0026#34;admin\u0026#34; $ export HARBOR_PASSWORD=\u0026#34;Harbor12345\u0026#34; Next, deploy the CRD and run the controller:\n$ make generate # gen crds \u0026amp; manifests $ make install # install crds $ make run  Developing Now you\u0026rsquo;re set to do your changes. Please keep in mind:\n if you add a feature, please add documentation about the usage and write tests that cover at least the happy path  Commit Messages This projects follows the Conventional Commits specification.\nReconciliation loop This is pretty straight-forward:\n find harbor projects that match the configured regular expression  reconcile robot accounts: i.e. (re-)create them if they do not exist, are disabled, expired or we do not manage the token  find namespaces using a mapping config  for each namespace: create a secret with type dockerconfigjson with the specified name.   The reconciliation loop is triggered from essentially three sources: * Control Plane: whenever a SyncConfig is created/updated/deleted * Harbor Polling: whenever the state in harbor changes (project or robota account is created, updated, deleted) * time-based using the configured force-sync-interval: forces reconciliation in a fixed interval to cover cases like namespace creation or robot account expiration\nArchitecture "},{"idx":2,"href":"/harbor-sync/docs/getting_started/","title":"Getting Started","content":" Getting Started What is Harbor Sync Controller? Harbor Sync Controller synchronizes Harbor with your Kubernetes cluster. It simplifies the management of robot accounts by automating the process of renewal and distribution of access tokens.\nInstallation Prerequisites Harbor You need a Harbor deployment and a user with elevated privileges to read all projects and robot accounts: Create a dedicated user with ProjectAdmin permissions. Refer to the official docs about how to set up user authentication and role binding.\nAlso, check your harbor version. It must be \u0026gt;= 1.8.0. That\u0026rsquo;s the version that introduced robot accounts. Prior to that version it was not possible to create robot accounts.\nKubernetes Cluster The Controller runs in Kubernetes so you need a Kubernetes Cluster, too.\nDeployment The following command creates a deployment and the necessary RBAC roles for the controller.\n$ wget https://raw.githubusercontent.com/moolen/harbor-sync/master/install/kubernetes/quick-install.yaml # change environment variables $ vim quick-install.yaml $ kubectl create -f quick-install.yaml Also, take a look at the kustomize setup if you use kustomize. If you prefer to use helm for deployment feel free to contribute a helm chart.\n"},{"idx":3,"href":"/harbor-sync/docs/metrics/","title":"Metrics","content":" Metrics Harbor Sync Controller exposes prometheus metrics. You configure the listen address / port via -metrics-addr. The following metrics are available:\n   metric name type labels description     http_request_duration_seconds histogram code,method,path keeps track of the duration API requests towards harbor   harbor_matching_projects gauge config,selector_type,selector_project_name total number of matching projects per HarborSyncConfig   harbor_robot_account_expiry gauge project,robot the date after which the robot account expires, expressed as Unix Epoch Time    "},{"idx":4,"href":"/harbor-sync/docs/spec/","title":"Spec","content":" Spec SyncConfig This is the root-level type.\ntype HarborSync struct { metav1.TypeMeta `json:\u0026#34;,inline\u0026#34;` metav1.ObjectMeta `json:\u0026#34;metadata,omitempty\u0026#34;` Spec HarborSyncSpec `json:\u0026#34;spec,omitempty\u0026#34;` // Status stores the plain credentials of the robot accounts \t// this is necessary, because the credentials are not accessible via API \tStatus HarborSyncStatus `json:\u0026#34;status,omitempty\u0026#34;` } HarborSyncSpec ProjectSelector specifies how to find projects in harbor and how to map those to secrets in namespaces. The robotAccountSuffix field defines what names the robot accounts have. The robot accounts always have a prefix of robot$ - this is behavior is enforced by Harbor and might change in the future.\n// HarborSyncSpec defines the desired state // how should harbor projects map to secrets in namespaces type HarborSyncSpec struct { // Specifies how to do matching on a harbor project. \t// Valid values are: \t// - \u0026#34;Regex\u0026#34; (default): interpret the project name as regular expression; \tType ProjectMatchingType `json:\u0026#34;type\u0026#34;` // ProjectName specifies the project name \tProjectName string `json:\u0026#34;name\u0026#34;` // TODO: \t// AccessType: ReadOnly|ReadWrite  // The RobotAccountSuffix specifies the suffix to use when creating a new robot account \t// +kubebuilder:validation:MinLength=4 \tRobotAccountSuffix string `json:\u0026#34;robotAccountSuffix\u0026#34;` // The Mapping contains the mapping from project to a secret in a namespace \tMapping []ProjectMapping `json:\u0026#34;mapping\u0026#34;` // Webhook is WIP \t// +optional \tWebhook []WebhookConfig `json:\u0026#34;webhook,omitempty\u0026#34;` } ProjectMapping ProjectMapping defines how to lookup namespaces in the cluster. Generally there are two lookup types: Translate and Match.\n// ProjectMapping defines how projects are mapped to secrets in specific namespaces type ProjectMapping struct { Type MappingType `json:\u0026#34;type\u0026#34;` Namespace string `json:\u0026#34;namespace\u0026#34;` Secret string `json:\u0026#34;secret\u0026#34;` } // MappingType specifies how to map the project into the namespace/secret // Only one of the following matching types may be specified. // If none of the following types is specified, the default one // is Translate. // +kubebuilder:validation:Enum=Translate;Match type MappingType string const ( // TranslateMappingType interpolates the project expression into the namespace \tTranslateMappingType MappingType = \u0026#34;Translate\u0026#34; // MatchMappingType treats the Namespace as regular expression and injects secrets into \t// all matching namespaces \tMatchMappingType MappingType = \u0026#34;Match\u0026#34; )"},{"idx":5,"href":"/harbor-sync/docs/usage/","title":"Usage","content":" Usage examples Map projects by name Map harbor project to several namespaces. This will create a robot account in my-project harbor project and sync the credentials into team-a and team-b\u0026rsquo;s namespace as secret central-project-token.\nkind: HaborSync metadata: name: my-project spec: type: Regex name: \u0026#34;my-project\u0026#34; # \u0026lt;--- specify harbor project robotAccountSuffix: \u0026#34;k8s-sync-robot\u0026#34; mapping: - type: Translate namespace: \u0026#34;team-a\u0026#34; # \u0026lt;--- target namespace secret: \u0026#34;my-project-pull-token\u0026#34; # \u0026lt;--- target secret name - type: Translate namespace: \u0026#34;team-b\u0026#34; secret: \u0026#34;my-project-pull-token\u0026#34; Map projects using a regular expression You can specify regular expressions to map a large number of projects to namespaces. This maps harbor teams with the prefix team-. E.g. Harbor project team-frontend maps to k8s namespace team-frontend. The secret\u0026rsquo;s name will always be my-pull-token. Non-existent k8s namespaces will be ignored.\nkind: HaborSync metadata: name: team-projects spec: type: Regex name: \u0026#34;team-(.*)\u0026#34; # find harbor projects matching this expression robotAccountSuffix: \u0026#34;k8s-sync-robot\u0026#34; mapping: - type: Translate namespace: \u0026#34;team-$1\u0026#34; # references capturing group from the above projectSelector.name secret: \u0026#34;team-$1-pull-token\u0026#34; # also here Map projects using regular expressions #2 You have one harbor project and want to deploy the pull secrets into several namespaces matching a regular expression. E.g. pull tokens for the platform-team project should be distributed into all namespaces matching team-.*.\nUse a type: Match on a mapping to say: hey, find namespaces using this regular expression at the namespace field rather than re-using the project name using type: Translate.\nkind: HaborSync metadata: name: platform-team spec: type: Regex name: \u0026#34;platform-team\u0026#34; robotAccountSuffix: \u0026#34;k8s-sync-robot\u0026#34; mapping: - type: Match # treat namespace as regexp namespace: \u0026#34;team-.*\u0026#34; # if ns matches this it will receive the secret secret: \u0026#34;platform-pull-token\u0026#34; # you can still use the capturing group from projectSelector.Name here Mapping Projects A mapping defines how to lookup namespaces in the cluster. Generally there are two lookup types: Translate and Match.\nTranslate Translate will take the Harbor project name into account when looking up namespaces. The ProjectSelector.ProjectName can be a regular expression which holds capturing groups. The idea is to inject those capturing groups when finding namespaces.\nExample:\nHarbor: we have two projects, team-frontend and team-backend. We select them using team-(.*) in the ProjectSelector.ProjectName. And map them to kubernetes namespaces squad-$1. The $1 will be replaced with frontend and backend respectively. In the end each namespaces will have only it\u0026rsquo;s own secret: team-frontend will only have the secret of Harbor project team-frontend. Namespace team-backend will only have the secret of Harbor project team-backend.\nMatch Match doesn\u0026rsquo;t care about the ProjectSelector.ProjectName. It will just find namespaces in the cluster that match the regular expression.\nExample 1:\nHarbor: we have one project, team-platform. By setting the field ProjectMapping.Namespace to team-.* we deploy the robot account secret to namespaces\nExample 2:\nHarbor: we have two projects, team-platform and team-operations. By setting ProjectMapping.Namespace to team-.* we deploy the robot accounts of both the platform and operations project into the namespace. To avoid naming conflicts on the secrets we set ProjectMapping.Secret to $1-pull-token. The result is: All namespaces matching team-.* will have the secrets platform-pull-token and operations-pull-token.\n"},{"idx":6,"href":"/harbor-sync/categories/","title":"Categories","content":""},{"idx":7,"href":"/harbor-sync/docs/","title":"Docs","content":""},{"idx":8,"href":"/harbor-sync/tags/","title":"Tags","content":""},{"idx":9,"href":"/harbor-sync/","title":"Welcome","content":" Welcome This is the documentation for the Harbor Sync Controller.\nThis documentation is split for two audiences: user and developer.\nIf you\u0026rsquo;re new go ahead with the Getting Started guide.\n"}];window.bookSearch={pages:pages,idx:lunr(function(){this.ref("idx");this.field("title");this.field("content");pages.forEach(this.add,this);}),}})();