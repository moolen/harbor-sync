(function(){const pages=[{"idx":0,"href":"/harbor-sync/docs/configuration/","title":"Configuration","content":" Configuration The harbor-sync binary\nEnvironment Variables    ENV DEFAULT DESCRIPTION     HARBOR_API_ENDPOINT - specify the harbor URL   HARBOR_API_PREFIX - Prefix of the Harbor API. For Harbor v2 set this to \u0026lsquo;/api/v2.0/\u0026rsquo;   HARBOR_USERNAME - set the username used for authenticating with harbor   HARBOR_PASSWORD - password for harbor authentication   LEADER_ELECT true enable/disable leader election   NAMESPACE kube-system namespace in which harbor-sync runs (used for leader-election)   HARBOR_POLL_INTERVAL 5m poll interval to update harbor projects \u0026amp; robot accounts   FORCE_SYNC_INTERVAL 10m set this to force reconciliation after a certain time   ROTATION_INTERVAL 60m set this to rotate the credentials after the specified time    Running Harbor v2 This project supports harbor v2. You must set HARBOR_API_PREFIX to /api/v2.0/ to point the controller to the correct API endpoint\nCommand Line Interface The harbor-sync binary has a subcommand that starts sync process: controller.\nStandalone mode The controller may run in standalone mode: This removes the necessity to run inside the Kubernetes cluster. In this mode harbor-sync reads a config file (see kind: HarborSync and kind: HarborRobotAccount) and reconciles the robot accounts in Harbor. Webhooks will be called to propagate the credentials into other subsystems. The mappings field will have not effect - this is specific to Kubernetes. In standalone mode state (i.e. the credentials for the robot accounts) is stored on disk.\nController should run inside Kubernetes. It reconciles the desired state by managing the robot accounts in Harbor. Usage: harbor-sync controller [flags] harbor-sync controller [command] Available Commands: standalone Runs the controller in standalone mode. Does not require Kubernetes. It manages robot accounts and sends webhooks. Flags: --force-sync-interval duration set this to force reconciliation after a certain time (default 10m0s) --harbor-api-endpoint string URL to the Harbor API Endpoint --harbor-api-prefix string Prefix of the Harbor API. For Harbor v2 set this to '/api/v2.0/' (default /api/) --harbor-password string Harbor password to use for authentication --harbor-poll-interval duration poll interval to update harbor projects \u0026amp; robot accounts (default 5m0s) --harbor-username string Harbor username to use for authentication -h, --help help for controller --leader-elect enable leader election (default true) --metrics-addr string The address the metric endpoint binds to. (default \u0026quot;:8080\u0026quot;) --namespace string namespace in which harbor-sync runs (used for leader-election) (default \u0026quot;kube-system\u0026quot;) --rotation-interval duration set this to rotate the credentials after the specified time (default 1h0m0s) --skip-tls-verification Skip TLS certificate verification Global Flags: --loglevel string set the loglevel (default \u0026quot;info\u0026quot;)  "},{"idx":1,"href":"/harbor-sync/docs/development/","title":"Development","content":" Development This document explains you how to get started with developing harbor-sync. It shows you how to install the prerequisites and how to build, test and run the controller.\nGet the code $ git clone https://github.com/moolen/harbor-sync.git ~/dev/harbor-sync $ cd ~/dev/harbor-sync Installing the test environment Prerequisites:  Vagrant must be installed Minikube must be installed Kubebuilder must be installed  Use the provided Vagrantfile to spin up a harbor instance.\n$ vagrant up Right now you need to click your way through harbor to create the projects for testing. Once the installation is done harbor tells you the ip address for this installation (e.g. http://172.28.128.XXX.xip.io.).\nIf it is not yet running ssh into the machine and try to start the containers with docker-compose:\n$ vagrant ssh vagrant@harbor:~$ sudo docker-compose -f harbor/docker-compose.yml up -d Tell the manager to access this deployment using environment variables:\n$ export HARBOR_API_ENDPOINT=http://172.28.128.XXX.xip.io. $ export HARBOR_USERNAME=\u0026#34;admin\u0026#34; $ export HARBOR_PASSWORD=\u0026#34;Harbor12345\u0026#34; Next, deploy the CRD and run the controller:\n$ make generate # gen crds \u0026amp; manifests $ make install # install crds $ make run  Developing Now you\u0026rsquo;re set to do your changes. Please keep in mind:\n if you add a feature, please add documentation about the usage and write tests that cover at least the happy path\n run make e2e to run e2e tests\n  Commit Messages This projects follows the Conventional Commits specification.\nDocumentation The documentation is hosted via GitHub pages. They are part of the repository and are located in the docs folder. If you change the documentation please regenerate the static site using make docs and include those changes in the PR too. You may find it useful to preview the compiled docs. Run make docs-live to view them in your browser.\nReconciliation loop This is pretty straight-forward:\n find harbor projects that match the configured regular expression  reconcile robot accounts: i.e. (re-)create them if they do not exist, are disabled, expired or we do not manage the token  find namespaces using a mapping config  for each namespace: create a secret with type dockerconfigjson with the specified name.   The reconciliation loop is triggered from essentially three sources: * Control Plane: whenever a SyncConfig is created/updated/deleted * Harbor Polling: whenever the state in harbor changes (project or robota account is created, updated, deleted) * time-based using the configured force-sync-interval: forces reconciliation in a fixed interval to cover cases like namespace creation or robot account expiration\nArchitecture "},{"idx":2,"href":"/harbor-sync/docs/getting_started/","title":"Getting Started","content":" Getting Started What is Harbor Sync Controller? Harbor Sync Controller synchronizes Harbor with your Kubernetes cluster. It simplifies the management of robot accounts by automating the process of renewal and distribution of access tokens.\nInstallation Prerequisites Harbor You need a Harbor deployment and a user with elevated privileges to read all projects and robot accounts: Create a dedicated user with ProjectAdmin permissions. Refer to the official docs about how to set up user authentication and role binding.\nAlso, check your harbor version. It must be \u0026gt;= 1.8.0. That\u0026rsquo;s the version that introduced robot accounts. Prior to that version it was not possible to create robot accounts.\nExecution Environment The Controller usually runs in Kubernetes so you need a Kubernetes Cluster, too. Also, you can run this controller in a standalone mode.\nDeployment The following command creates a deployment and the necessary RBAC roles for the controller.\n$ wget https://raw.githubusercontent.com/moolen/harbor-sync/master/install/kubernetes/quick-install.yaml # change environment variables $ vim quick-install.yaml $ kubectl create -f quick-install.yaml Also, take a look at the kustomize setup if you use kustomize. If you prefer to use helm for deployment feel free to contribute a helm chart.\nImportant Notes Harbor Sync Controller is stateless. Right now, harbor-sync stores the credentials for the robot accounts in a crd. This is necessary because there is no way to retrieve the token from the harbor API.\nYou can inspect the robot account credentials using: kubectl get harborrobotaccount.\nNext steps You may want to check out the the Usage Examples or Configuration.\n"},{"idx":3,"href":"/harbor-sync/docs/metrics/","title":"Metrics","content":" Metrics Harbor Sync Controller exposes prometheus metrics. You configure the listen address / port via -metrics-addr. The following metrics are available:\n   metric name type labels description     http_request_duration_seconds histogram code,method,path keeps track of the duration API requests towards harbor   harbor_matching_projects gauge config,selector_type,selector_project_name total number of matching projects per HarborSyncConfig   harbor_robot_account_expiry gauge project,robot the date after which the robot account expires, expressed as Unix Epoch Time   harbor_sync_sent_webhooks gauge config,target,status_code The number of webhooks sent    Alerts Here are example alerts\ngroups: - name: harbor_rules rules: - alert: HarborAccountExpires expr: (harbor_robot_account_expiry - time()) / 86400 \u0026lt; 14 for: 10m labels: severity: warning annotations: summary: \u0026#34;CRITICAL: harbor robot account \u0026#39;{{ $labels.robot }}\u0026#39; in project \u0026#39;{{ $labels.project }}\u0026#39; expires in less than 14d\u0026#34; description: \u0026#34;harbor robot account expires soon\u0026#34; - alert: HarborOutgoingWebhooksFailed expr: sum(increase(harbor_sync_sent_webhooks{status_code!=\u0026#34;200\u0026#34;}[1h])) by (target) \u0026gt; 0 labels: severity: critical annotations: summary: \u0026#34;CRITICAL: harbor outgoing webhook failed: \u0026#39;{{ $labels.target }}\u0026#39;\u0026#34; description: \u0026#34;harbor does not deliver the robot account information correctly\u0026#34;"},{"idx":4,"href":"/harbor-sync/docs/spec/","title":"Spec","content":" Spec SyncConfig This is the root-level type.\ntype HarborSync struct { metav1.TypeMeta `json:\u0026#34;,inline\u0026#34;` metav1.ObjectMeta `json:\u0026#34;metadata,omitempty\u0026#34;` Spec HarborSyncSpec `json:\u0026#34;spec,omitempty\u0026#34;` } HarborSyncSpec ProjectSelector specifies how to find projects in harbor and how to map those to secrets in namespaces. The robotAccountSuffix field defines what names the robot accounts have. The robot accounts always have a prefix of robot$ - this is behavior is enforced by Harbor and might change in the future.\nNote: The robot account suffix should be unique per HarborSync. If you map projects twice using two different HarborSync configurations you end up with a race condition.\n// HarborSyncSpec defines the desired state // how should harbor projects map to secrets in namespaces type HarborSyncSpec struct { // Specifies how to do matching on a harbor project. \t// Valid values are: \t// - \u0026#34;Regex\u0026#34; (default): interpret the project name as regular expression; \tType ProjectMatchingType `json:\u0026#34;type\u0026#34;` // ProjectName specifies the project name \tProjectName string `json:\u0026#34;name\u0026#34;` // PushAccess allows the robot account to push images, too. defaults to false. \t// As of now we can not tell what permissions a robot account has. The user \t// has to wait for the next rotation until the robot account has the new permissions. \t// Alternatively, you can re-create your HarborSync spec. This forces a rotation. \tPushAccess bool `json:\u0026#34;pushAccess\u0026#34;` // The RobotAccountSuffix specifies the suffix to use when creating a new robot account \t// +kubebuilder:validation:MinLength=4 \tRobotAccountSuffix string `json:\u0026#34;robotAccountSuffix\u0026#34;` // The Mapping contains the mapping from project to a secret in a namespace \tMapping []ProjectMapping `json:\u0026#34;mapping,omitempty\u0026#34;` // Webhook contains a list of endpoints which will be called \t// if the robot account changes (e..g automatic rotation, expired account, disabled...) \t// +optional \tWebhook []WebhookConfig `json:\u0026#34;webhook,omitempty\u0026#34;` } ProjectMapping ProjectMapping defines how to lookup namespaces in the cluster. Generally there are two lookup types: Translate and Match.\n// ProjectMapping defines how projects are mapped to secrets in specific namespaces type ProjectMapping struct { Type MappingType `json:\u0026#34;type\u0026#34;` Namespace string `json:\u0026#34;namespace\u0026#34;` Secret string `json:\u0026#34;secret\u0026#34;` } // MappingType specifies how to map the project into the namespace/secret // Only one of the following matching types may be specified. // If none of the following types is specified, the default one // is Translate. // +kubebuilder:validation:Enum=Translate;Match type MappingType string const ( // TranslateMappingType interpolates the project expression into the namespace \tTranslateMappingType MappingType = \u0026#34;Translate\u0026#34; // MatchMappingType treats the Namespace as regular expression and injects secrets into \t// all matching namespaces \tMatchMappingType MappingType = \u0026#34;Match\u0026#34; ) Webhook Webhooks can be configured which will be called if the robot account credentials change. The only supported protocol is HTTP for now. Integrating other protocols is out of scope of this project. You should implement your own services that do the plumbing.\n// WebhookConfig defines how to call a webhook type WebhookConfig struct { // Endpoint is a url \tEndpoint string `json:\u0026#34;endpoint\u0026#34;` } // WebhookUpdatePayload ... type WebhookUpdatePayload struct { Project string `json:\u0026#34;project\u0026#34;` Credentials RobotAccountCredential `json:\u0026#34;credentials\u0026#34;` } // RobotAccountCredential holds the robot account name \u0026amp; token to access the harbor API type RobotAccountCredential struct { Name string `json:\u0026#34;name\u0026#34;` CreatedAt int64 `json:\u0026#34;created_at\u0026#34;` Token string `json:\u0026#34;token\u0026#34;` }"},{"idx":5,"href":"/harbor-sync/docs/usage/","title":"Usage","content":" Usage examples Map projects by name Map harbor project to several namespaces. This will create a robot account in my-project harbor project and sync the credentials into team-a and team-b\u0026rsquo;s namespace as secret central-project-token.\nkind: HarborSync metadata: name: my-project spec: type: Regex name: \u0026#34;my-project\u0026#34; # \u0026lt;--- specify harbor project robotAccountSuffix: \u0026#34;k8s-sync-robot\u0026#34; # \u0026lt;--- should be unique per kind: HarborSync mapping: - type: Translate namespace: \u0026#34;team-a\u0026#34; # \u0026lt;--- target namespace secret: \u0026#34;my-project-pull-token\u0026#34; # \u0026lt;--- target secret name - type: Translate namespace: \u0026#34;team-b\u0026#34; secret: \u0026#34;my-project-pull-token\u0026#34; Map projects using a regular expression You can specify regular expressions to map a large number of projects to namespaces. This maps harbor teams with the prefix team-. E.g. Harbor project team-frontend maps to k8s namespace team-frontend. The secret\u0026rsquo;s name will always be my-pull-token. Non-existent k8s namespaces will be ignored.\nkind: HarborSync metadata: name: team-projects spec: type: Regex name: \u0026#34;team-(.*)\u0026#34; # find harbor projects matching this expression robotAccountSuffix: \u0026#34;k8s-sync-robot\u0026#34; mapping: - type: Translate namespace: \u0026#34;team-$1\u0026#34; # references capturing group from the above projectSelector.name secret: \u0026#34;team-$1-pull-token\u0026#34; # also here Map projects using regular expressions #2 You have one harbor project and want to deploy the pull secrets into several namespaces matching a regular expression. E.g. pull tokens for the platform-team project should be distributed into all namespaces matching team-.*.\nUse a type: Match on a mapping to say: hey, find namespaces using this regular expression at the namespace field rather than re-using the project name using type: Translate.\nkind: HarborSync metadata: name: platform-team spec: type: Regex name: \u0026#34;platform-team\u0026#34; robotAccountSuffix: \u0026#34;k8s-sync-robot\u0026#34; mapping: - type: Match # treat namespace as regexp namespace: \u0026#34;team-.*\u0026#34; # if ns matches this it will receive the secret secret: \u0026#34;platform-pull-token\u0026#34; # you can still use the capturing group from projectSelector.Name here Mapping Projects A mapping defines how to lookup namespaces in the cluster. Generally there are two lookup types: Translate and Match.\nTranslate Translate will take the Harbor project name into account when looking up namespaces. The ProjectSelector.ProjectName can be a regular expression which holds capturing groups. The idea is to inject those capturing groups when finding namespaces.\nExample:\nHarbor: we have two projects, team-frontend and team-backend. We select them using team-(.*) in the ProjectSelector.ProjectName. And map them to kubernetes namespaces squad-$1. The $1 will be replaced with frontend and backend respectively. In the end each namespaces will have only it\u0026rsquo;s own secret: team-frontend will only have the secret of Harbor project team-frontend. Namespace team-backend will only have the secret of Harbor project team-backend.\nMatch Match doesn\u0026rsquo;t care about the ProjectSelector.ProjectName. It will just find namespaces in the cluster that match the regular expression.\nExample 1:\nHarbor: we have one project, team-platform. By setting the field ProjectMapping.Namespace to team-.* we deploy the robot account secret to namespaces\nExample 2:\nHarbor: we have two projects, team-platform and team-operations. By setting ProjectMapping.Namespace to team-.* we deploy the robot accounts of both the platform and operations project into the namespace. To avoid naming conflicts on the secrets we set ProjectMapping.Secret to $1-pull-token. The result is: All namespaces matching team-.* will have the secrets platform-pull-token and operations-pull-token.\nConfiguring Webhook Receiver Webhooks can be configured to notify other services whenever a Robot account is being recreated or refreshed. A POST Request is sent for every Robot account in every Project that has been (re-)created.\nExample HTTP Request:\nPOST / HTTP/1.1 Host: localhost:1938 User-Agent: Go-http-client/1.1 Content-Length: 77 Content-Type: application/json Accept-Encoding: gzip { \u0026quot;project\u0026quot;: \u0026quot;team-foo\u0026quot;, \u0026quot;credentials\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;robot$sync-bot\u0026quot;, \u0026quot;token\u0026quot;:\u0026quot;1234\u0026quot; } }  HarborSync CRD configuration:\nkind: HarborSync metadata: name: platform-team spec: type: Regex name: \u0026#34;team-(.*)\u0026#34; robotAccountSuffix: \u0026#34;k8s-sync-robot\u0026#34; mapping: [] # mappings are optional! # you can specify multiple webhooks webhook: - endpoint: http://example.com The only thing you can configure right now is a target endpoint for the HTTP request. Feel free to contribute or open an issue if you need more functionality.\n"},{"idx":6,"href":"/harbor-sync/categories/","title":"Categories","content":""},{"idx":7,"href":"/harbor-sync/docs/","title":"Docs","content":""},{"idx":8,"href":"/harbor-sync/tags/","title":"Tags","content":""},{"idx":9,"href":"/harbor-sync/","title":"Welcome","content":" Welcome This is the documentation for the Harbor Sync Controller.\nIf you\u0026rsquo;re new go ahead with the Getting Started guide.\nFor reference, take a look at Usage, Configuration or Spec.\n"}];window.bookSearch={pages:pages,idx:lunr(function(){this.ref("idx");this.field("title");this.field("content");pages.forEach(this.add,this);}),}})();